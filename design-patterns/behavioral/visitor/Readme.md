# Visitor

## üéØ Inten√ß√£o

O Visitor √© um padr√£o de projeto comportamental que permite **separar algoritmos dos objetos** nos quais eles operam. Ele permite adicionar novas opera√ß√µes a uma estrutura de objetos existente sem modificar essas classes, usando a t√©cnica de **Double Dispatch**.

## üö© Problema

Imagine que sua equipe desenvolve um app que trabalha com informa√ß√µes geogr√°ficas estruturadas como um grafo colossal. Cada n√≥ pode representar uma entidade complexa como cidade, ind√∫stria, √°rea tur√≠stica, etc. Cada tipo de n√≥ √© representado por sua pr√≥pria classe.

Voc√™ recebe a tarefa de implementar exporta√ß√£o do grafo para formato XML. A primeira ideia: adicionar m√©todo `export()` em cada classe de n√≥. Simples e elegante! Mas...

### Resultado problem√°tico:
```java
// Tentativa 1: Adicionar m√©todo export em cada classe
class City {
    private String name;
    private int population;
    
    // Comportamento principal
    public void updatePopulation() { /* ... */ }
    public void addIndustry() { /* ... */ }
    
    // ‚ùå NOVO: Export XML
    public String exportToXML() {
        return "<city><name>" + name + "</name></city>";
    }
}

class Industry {
    private String type;
    private int employees;
    
    // Comportamento principal
    public void hire() { /* ... */ }
    public void produce() { /* ... */ }
    
    // ‚ùå NOVO: Export XML
    public String exportToXML() {
        return "<industry><type>" + type + "</type></industry>";
    }
}

class SightSeeing {
    private String attraction;
    private double rating;
    
    // Comportamento principal
    public void updateRating() { /* ... */ }
    
    // ‚ùå NOVO: Export XML
    public String exportToXML() {
        return "<sight><name>" + attraction + "</name></sight>";
    }
}
```

**Problemas:**
- **Arquiteto recusa**: C√≥digo em produ√ß√£o, risco de quebrar
- **Responsabilidade errada**: Export XML n√£o √© trabalho de City/Industry
- **Viola√ß√£o SRP**: Classes fazem trabalho com geodata + export
- **Mudan√ßas futuras**: Marketing vai pedir JSON, CSV, PDF... üò±
- **Classes fr√°geis**: Cada novo formato = modificar todas classes
- **C√≥digo alien**: Export XML parece estranho em classes de geodata

### Tentativa 2: Condicionais no cliente

```java
// Cliente precisa saber tipo de cada n√≥
class GraphExporter {
    public void exportGraph(List<Node> nodes) {
        for (Node node : nodes) {
            // ‚ùå Type checking manual!
            if (node instanceof City) {
                exportCity((City) node);
            } else if (node instanceof Industry) {
                exportIndustry((Industry) node);
            } else if (node instanceof SightSeeing) {
                exportSightSeeing((SightSeeing) node);
            }
            // Adicionar novo tipo = modificar este c√≥digo!
        }
    }
    
    private void exportCity(City c) { /* ... */ }
    private void exportIndustry(Industry i) { /* ... */ }
    private void exportSightSeeing(SightSeeing s) { /* ... */ }
}
```

**Mais problemas:**
- **Type checking**: Precisa checar tipo de cada objeto
- **N√£o escal√°vel**: Adicionar tipo = modificar cliente
- **Sem polimorfismo**: Perdeu benef√≠cio de OOP
- **Conditional nightmare**: if/else gigante

## ‚úÖ Solu√ß√£o

O padr√£o Visitor sugere que voc√™ coloque o novo comportamento em uma classe separada chamada **visitor**, ao inv√©s de tentar integr√°-lo nas classes existentes. O objeto original √© passado para um m√©todo do visitor como argumento.

A m√°gica acontece com **Double Dispatch**: ao inv√©s do cliente escolher qual m√©todo chamar, os objetos delegam essa escolha. Eles "aceitam" o visitor e dizem qual m√©todo visitar deve ser executado.

### Caracter√≠sticas-chave:
- **Separa√ß√£o de algoritmos**: Comportamentos em classes visitor separadas
- **Double Dispatch**: Duas chamadas polim√≥rficas para resolver tipo
- **M√©todo accept()**: Elementos aceitam visitor
- **Opera√ß√µes sem modificar**: Adiciona opera√ß√µes sem mudar elementos
- **Open/Closed**: Aberto para extens√£o (novos visitors), fechado para modifica√ß√£o

```java
// Interface Visitor
interface Visitor {
    void visitCity(City city);
    void visitIndustry(Industry industry);
    void visitSightSeeing(SightSeeing sight);
}

// Interface Element
interface Element {
    void accept(Visitor visitor);
}

// Concrete Elements
class City implements Element {
    private String name;
    private int population;
    
    public City(String name, int population) {
        this.name = name;
        this.population = population;
    }
    
    // Comportamento principal da classe
    public void updatePopulation() { /* ... */ }
    
    // DOUBLE DISPATCH: City conhece sua pr√≥pria classe
    @Override
    public void accept(Visitor visitor) {
        visitor.visitCity(this); // Chama m√©todo espec√≠fico para City
    }
    
    public String getName() { return name; }
    public int getPopulation() { return population; }
}

class Industry implements Element {
    private String type;
    private int employees;
    
    public Industry(String type, int employees) {
        this.type = type;
        this.employees = employees;
    }
    
    @Override
    public void accept(Visitor visitor) {
        visitor.visitIndustry(this); // Chama m√©todo espec√≠fico para Industry
    }
    
    public String getType() { return type; }
    public int getEmployees() { return employees; }
}

// Concrete Visitor - XML Export
class XMLExportVisitor implements Visitor {
    private StringBuilder xml = new StringBuilder();
    
    @Override
    public void visitCity(City city) {
        xml.append("<city>")
           .append("<name>").append(city.getName()).append("</name>")
           .append("<population>").append(city.getPopulation()).append("</population>")
           .append("</city>\n");
    }
    
    @Override
    public void visitIndustry(Industry industry) {
        xml.append("<industry>")
           .append("<type>").append(industry.getType()).append("</type>")
           .append("<employees>").append(industry.getEmployees()).append("</employees>")
           .append("</industry>\n");
    }
    
    @Override
    public void visitSightSeeing(SightSeeing sight) {
        xml.append("<sight>")
           .append("<name>").append(sight.getName()).append("</name>")
           .append("</sight>\n");
    }
    
    public String getXML() {
        return xml.toString();
    }
}

// Uso - SEM type checking!
List<Element> elements = Arrays.asList(
    new City("S√£o Paulo", 12_000_000),
    new Industry("Tech", 5000),
    new SightSeeing("Museu")
);

XMLExportVisitor xmlVisitor = new XMLExportVisitor();
for (Element element : elements) {
    element.accept(xmlVisitor); // Polimorfismo!
}
System.out.println(xmlVisitor.getXML());

// Adicionar novo formato √© f√°cil!
JSONExportVisitor jsonVisitor = new JSONExportVisitor();
for (Element element : elements) {
    element.accept(jsonVisitor); // Mesmo c√≥digo!
}
```

## üèóÔ∏è Estrutura

```
Visitor (interface)                Element (interface)
    ‚Üì                                      ‚Üì
visitConcreteA(ConcreteA)             accept(Visitor)
visitConcreteB(ConcreteB)                  ‚Üë
    ‚Üë                                      |
ConcreteVisitor1  ConcreteVisitor2    ConcreteElementA  ConcreteElementB
       ‚Üì                 ‚Üì                    ‚Üì                ‚Üì
  visitConcreteA()  visitConcreteA()    accept(v) {      accept(v) {
  visitConcreteB()  visitConcreteB()      v.visitA(this)   v.visitB(this)
                                        }                 }

Client
   ‚Üì
foreach element in structure:
   element.accept(visitor)  ‚Üê DOUBLE DISPATCH!
```

### Componentes:
- **Visitor**: Interface com m√©todo de visita para cada ConcreteElement
- **ConcreteVisitor**: Implementa opera√ß√£o espec√≠fica para cada elemento
- **Element**: Interface com m√©todo `accept(Visitor)`
- **ConcreteElement**: Implementa `accept()` chamando m√©todo visitor apropriado
- **Client**: Itera elementos e chama `accept()`

### Double Dispatch explicado:
1. **Primeira dispatch**: `element.accept(visitor)` - polimorfismo escolhe implementa√ß√£o de `accept()` baseado no tipo de element
2. **Segunda dispatch**: `visitor.visitCity(this)` - polimorfismo escolhe m√©todo correto no visitor baseado no tipo do par√¢metro

## üíª Exemplos Pr√°ticos

### Exemplo 1: Sistema de Impostos para Diferentes Tipos de Produtos

```java
// Interface Element
interface Product {
    void accept(ProductVisitor visitor);
}

// Concrete Elements
class Food implements Product {
    private String name;
    private double price;
    private boolean organic;
    
    public Food(String name, double price, boolean organic) {
        this.name = name;
        this.price = price;
        this.organic = organic;
    }
    
    @Override
    public void accept(ProductVisitor visitor) {
        visitor.visitFood(this);
    }
    
    public String getName() { return name; }
    public double getPrice() { return price; }
    public boolean isOrganic() { return organic; }
}

class Electronics implements Product {
    private String name;
    private double price;
    private int warrantyYears;
    
    public Electronics(String name, double price, int warrantyYears) {
        this.name = name;
        this.price = price;
        this.warrantyYears = warrantyYears;
    }
    
    @Override
    public void accept(ProductVisitor visitor) {
        visitor.visitElectronics(this);
    }
    
    public String getName() { return name; }
    public double getPrice() { return price; }
    public int getWarrantyYears() { return warrantyYears; }
}

class Clothing implements Product {
    private String name;
    private double price;
    private String size;
    private boolean imported;
    
    public Clothing(String name, double price, String size, boolean imported) {
        this.name = name;
        this.price = price;
        this.size = size;
        this.imported = imported;
    }
    
    @Override
    public void accept(ProductVisitor visitor) {
        visitor.visitClothing(this);
    }
    
    public String getName() { return name; }
    public double getPrice() { return price; }
    public String getSize() { return size; }
    public boolean isImported() { return imported; }
}

class Beverage implements Product {
    private String name;
    private double price;
    private boolean alcoholic;
    
    public Beverage(String name, double price, boolean alcoholic) {
        this.name = name;
        this.price = price;
        this.alcoholic = alcoholic;
    }
    
    @Override
    public void accept(ProductVisitor visitor) {
        visitor.visitBeverage(this);
    }
    
    public String getName() { return name; }
    public double getPrice() { return price; }
    public boolean isAlcoholic() { return alcoholic; }
}

// Interface Visitor
interface ProductVisitor {
    void visitFood(Food food);
    void visitElectronics(Electronics electronics);
    void visitClothing(Clothing clothing);
    void visitBeverage(Beverage beverage);
}

// Concrete Visitor 1 - Calculadora de Impostos
class TaxCalculatorVisitor implements ProductVisitor {
    private double totalTax = 0;
    
    @Override
    public void visitFood(Food food) {
        // Alimentos: 5% (ou isento se org√¢nico)
        double tax = food.isOrganic() ? 0 : food.getPrice() * 0.05;
        totalTax += tax;
        
        System.out.printf("üçé %s: $%.2f (Imposto: $%.2f - %.0f%%)%s\n",
            food.getName(),
            food.getPrice(),
            tax,
            food.isOrganic() ? 0 : 5,
            food.isOrganic() ? " [ORG√ÇNICO - ISENTO]" : ""
        );
    }
    
    @Override
    public void visitElectronics(Electronics electronics) {
        // Eletr√¥nicos: 18%
        double tax = electronics.getPrice() * 0.18;
        totalTax += tax;
        
        System.out.printf("üì± %s: $%.2f (Imposto: $%.2f - 18%%) [Garantia: %d anos]\n",
            electronics.getName(),
            electronics.getPrice(),
            tax,
            electronics.getWarrantyYears()
        );
    }
    
    @Override
    public void visitClothing(Clothing clothing) {
        // Roupas: 12% (ou 25% se importada)
        double taxRate = clothing.isImported() ? 0.25 : 0.12;
        double tax = clothing.getPrice() * taxRate;
        totalTax += tax;
        
        System.out.printf("üëï %s (%s): $%.2f (Imposto: $%.2f - %.0f%%)%s\n",
            clothing.getName(),
            clothing.getSize(),
            clothing.getPrice(),
            tax,
            taxRate * 100,
            clothing.isImported() ? " [IMPORTADA]" : ""
        );
    }
    
    @Override
    public void visitBeverage(Beverage beverage) {
        // Bebidas: 8% (ou 45% se alco√≥lica)
        double taxRate = beverage.isAlcoholic() ? 0.45 : 0.08;
        double tax = beverage.getPrice() * taxRate;
        totalTax += tax;
        
        System.out.printf("ü•§ %s: $%.2f (Imposto: $%.2f - %.0f%%)%s\n",
            beverage.getName(),
            beverage.getPrice(),
            tax,
            taxRate * 100,
            beverage.isAlcoholic() ? " [ALCO√ìLICA]" : ""
        );
    }
    
    public double getTotalTax() {
        return totalTax;
    }
    
    public void reset() {
        totalTax = 0;
    }
}

// Concrete Visitor 2 - Gerador de Etiquetas
class LabelGeneratorVisitor implements ProductVisitor {
    
    @Override
    public void visitFood(Food food) {
        System.out.println("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
        System.out.println("‚îÇ    ALIMENTO                     ‚îÇ");
        System.out.println("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§");
        System.out.printf("‚îÇ %-31s ‚îÇ\n", food.getName());
        System.out.printf("‚îÇ Pre√ßo: $%-22.2f ‚îÇ\n", food.getPrice());
        System.out.printf("‚îÇ %s ‚îÇ\n", 
            food.isOrganic() ? "‚úì ORG√ÇNICO                     " : "                               ");
        System.out.println("‚îÇ Validade: Ver embalagem         ‚îÇ");
        System.out.println("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n");
    }
    
    @Override
    public void visitElectronics(Electronics electronics) {
        System.out.println("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
        System.out.println("‚îÇ    ELETR√îNICOS                  ‚îÇ");
        System.out.println("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§");
        System.out.printf("‚îÇ %-31s ‚îÇ\n", electronics.getName());
        System.out.printf("‚îÇ Pre√ßo: $%-22.2f ‚îÇ\n", electronics.getPrice());
        System.out.printf("‚îÇ Garantia: %d anos %-14s ‚îÇ\n", 
            electronics.getWarrantyYears(), "");
        System.out.println("‚îÇ ‚ö†Ô∏è  N√£o jogue no lixo comum      ‚îÇ");
        System.out.println("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n");
    }
    
    @Override
    public void visitClothing(Clothing clothing) {
        System.out.println("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
        System.out.println("‚îÇ    VESTU√ÅRIO                    ‚îÇ");
        System.out.println("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§");
        System.out.printf("‚îÇ %-31s ‚îÇ\n", clothing.getName());
        System.out.printf("‚îÇ Tamanho: %-22s ‚îÇ\n", clothing.getSize());
        System.out.printf("‚îÇ Pre√ßo: $%-22.2f ‚îÇ\n", clothing.getPrice());
        System.out.printf("‚îÇ %s ‚îÇ\n",
            clothing.isImported() ? "üåç IMPORTADO                   " : "üáßüá∑ FABRICADO NO BRASIL         ");
        System.out.println("‚îÇ Instru√ß√µes: Ver etiqueta        ‚îÇ");
        System.out.println("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n");
    }
    
    @Override
    public void visitBeverage(Beverage beverage) {
        System.out.println("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
        System.out.println("‚îÇ    BEBIDA                       ‚îÇ");
        System.out.println("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§");
        System.out.printf("‚îÇ %-31s ‚îÇ\n", beverage.getName());
        System.out.printf("‚îÇ Pre√ßo: $%-22.2f ‚îÇ\n", beverage.getPrice());
        System.out.printf("‚îÇ %s ‚îÇ\n",
            beverage.isAlcoholic() ? "üîû CONT√âM √ÅLCOOL               " : "                               ");
        if (beverage.isAlcoholic()) {
            System.out.println("‚îÇ ‚ö†Ô∏è  Venda proibida p/ menores   ‚îÇ");
        }
        System.out.println("‚îÇ Conservar em local fresco       ‚îÇ");
        System.out.println("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n");
    }
}

// Concrete Visitor 3 - Calculadora de Frete
class ShippingCostVisitor implements ProductVisitor {
    private double totalShipping = 0;
    
    @Override
    public void visitFood(Food food) {
        // Alimentos: $5 fixo
        double shipping = 5.00;
        totalShipping += shipping;
        System.out.printf("üì¶ %s: Frete $%.2f (padr√£o)\n", food.getName(), shipping);
    }
    
    @Override
    public void visitElectronics(Electronics electronics) {
        // Eletr√¥nicos: $15 + seguro
        double shipping = 15.00 + (electronics.getPrice() * 0.02);
        totalShipping += shipping;
        System.out.printf("üì¶ %s: Frete $%.2f ($15 base + $%.2f seguro)\n",
            electronics.getName(), shipping, electronics.getPrice() * 0.02);
    }
    
    @Override
    public void visitClothing(Clothing clothing) {
        // Roupas: $8 (ou $12 se importada)
        double shipping = clothing.isImported() ? 12.00 : 8.00;
        totalShipping += shipping;
        System.out.printf("üì¶ %s: Frete $%.2f%s\n",
            clothing.getName(), shipping,
            clothing.isImported() ? " (taxa internacional)" : "");
    }
    
    @Override
    public void visitBeverage(Beverage beverage) {
        // Bebidas: $7 (embalagem especial para l√≠quidos)
        double shipping = 7.00;
        totalShipping += shipping;
        System.out.printf("üì¶ %s: Frete $%.2f (embalagem especial)\n",
            beverage.getName(), shipping);
    }
    
    public double getTotalShipping() {
        return totalShipping;
    }
    
    public void reset() {
        totalShipping = 0;
    }
}

// Concrete Visitor 4 - Relat√≥rio Detalhado
class DetailedReportVisitor implements ProductVisitor {
    private int foodCount = 0;
    private int electronicsCount = 0;
    private int clothingCount = 0;
    private int beverageCount = 0;
    private double totalValue = 0;
    
    @Override
    public void visitFood(Food food) {
        foodCount++;
        totalValue += food.getPrice();
    }
    
    @Override
    public void visitElectronics(Electronics electronics) {
        electronicsCount++;
        totalValue += electronics.getPrice();
    }
    
    @Override
    public void visitClothing(Clothing clothing) {
        clothingCount++;
        totalValue += clothing.getPrice();
    }
    
    @Override
    public void visitBeverage(Beverage beverage) {
        beverageCount++;
        totalValue += beverage.getPrice();
    }
    
    public void printReport() {
        System.out.println("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        System.out.println("         RELAT√ìRIO DE PRODUTOS");
        System.out.println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        System.out.printf("üçé Alimentos:    %d item(s)\n", foodCount);
        System.out.printf("üì± Eletr√¥nicos:  %d item(s)\n", electronicsCount);
        System.out.printf("üëï Vestu√°rio:    %d item(s)\n", clothingCount);
        System.out.printf("ü•§ Bebidas:      %d item(s)\n", beverageCount);
        System.out.println("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
        System.out.printf("üìä Total:        %d item(s)\n", 
            foodCount + electronicsCount + clothingCount + beverageCount);
        System.out.printf("üí∞ Valor Total:  $%.2f\n", totalValue);
        System.out.println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
    }
}

// Uso
public class TaxSystemExample {
    public static void main(String[] args) {
        System.out.println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        System.out.println("    SISTEMA DE GEST√ÉO DE PRODUTOS");
        System.out.println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        
        // Cria carrinho de produtos
        List<Product> cart = Arrays.asList(
            new Food("Ma√ß√£ Org√¢nica", 5.99, true),
            new Food("Arroz 5kg", 12.50, false),
            new Electronics("Smartphone", 1200.00, 2),
            new Electronics("Fone Bluetooth", 150.00, 1),
            new Clothing("Camiseta", 49.90, "M", false),
            new Clothing("Jaqueta Importada", 299.00, "L", true),
            new Beverage("Suco Natural", 6.50, false),
            new Beverage("Vinho Tinto", 85.00, true)
        );
        
        // Visitor 1: C√°lculo de Impostos
        System.out.println("### C√ÅLCULO DE IMPOSTOS ###\n");
        TaxCalculatorVisitor taxVisitor = new TaxCalculatorVisitor();
        for (Product product : cart) {
            product.accept(taxVisitor);
        }
        System.out.println("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
        System.out.printf("üí∞ TOTAL DE IMPOSTOS: $%.2f\n\n", taxVisitor.getTotalTax());
        
        // Visitor 2: Gera√ß√£o de Etiquetas
        System.out.println("\n### GERA√á√ÉO DE ETIQUETAS ###\n");
        LabelGeneratorVisitor labelVisitor = new LabelGeneratorVisitor();
        for (Product product : cart) {
            product.accept(labelVisitor);
        }
        
        // Visitor 3: C√°lculo de Frete
        System.out.println("\n### C√ÅLCULO DE FRETE ###\n");
        ShippingCostVisitor shippingVisitor = new ShippingCostVisitor();
        for (Product product : cart) {
            product.accept(shippingVisitor);
        }
        System.out.println("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
        System.out.printf("üì¶ TOTAL DE FRETE: $%.2f\n", shippingVisitor.getTotalShipping());
        
        // Visitor 4: Relat√≥rio Detalhado
        DetailedReportVisitor reportVisitor = new DetailedReportVisitor();
        for (Product product : cart) {
            product.accept(reportVisitor);
        }
        reportVisitor.printReport();
    }
}
```

### Exemplo 2: Sistema de An√°lise de Express√µes Matem√°ticas

```java
// Interface Element - Express√µes
interface Expression {
    void accept(ExpressionVisitor visitor);
}

// Concrete Elements - N√∫meros e Opera√ß√µes
class NumberExpression implements Expression {
    private double value;
    
    public NumberExpression(double value) {
        this.value = value;
    }
    
    @Override
    public void accept(ExpressionVisitor visitor) {
        visitor.visitNumber(this);
    }
    
    public double getValue() {
        return value;
    }
}

class AdditionExpression implements Expression {
    private Expression left;
    private Expression right;
    
    public AdditionExpression(Expression left, Expression right) {
        this.left = left;
        this.right = right;
    }
    
    @Override
    public void accept(ExpressionVisitor visitor) {
        visitor.visitAddition(this);
    }
    
    public Expression getLeft() { return left; }
    public Expression getRight() { return right; }
}

class SubtractionExpression implements Expression {
    private Expression left;
    private Expression right;
    
    public SubtractionExpression(Expression left, Expression right) {
        this.left = left;
        this.right = right;
    }
    
    @Override
    public void accept(ExpressionVisitor visitor) {
        visitor.visitSubtraction(this);
    }
    
    public Expression getLeft() { return left; }
    public Expression getRight() { return right; }
}

class MultiplicationExpression implements Expression {
    private Expression left;
    private Expression right;
    
    public MultiplicationExpression(Expression left, Expression right) {
        this.left = left;
        this.right = right;
    }
    
    @Override
    public void accept(ExpressionVisitor visitor) {
        visitor.visitMultiplication(this);
    }
    
    public Expression getLeft() { return left; }
    public Expression getRight() { return right; }
}

class DivisionExpression implements Expression {
    private Expression left;
    private Expression right;
    
    public DivisionExpression(Expression left, Expression right) {
        this.left = left;
        this.right = right;
    }
    
    @Override
    public void accept(ExpressionVisitor visitor) {
        visitor.visitDivision(this);
    }
    
    public Expression getLeft() { return left; }
    public Expression getRight() { return right; }
}

// Interface Visitor
interface ExpressionVisitor {
    void visitNumber(NumberExpression number);
    void visitAddition(AdditionExpression addition);
    void visitSubtraction(SubtractionExpression subtraction);
    void visitMultiplication(MultiplicationExpression multiplication);
    void visitDivision(DivisionExpression division);
}

// Concrete Visitor 1 - Calculadora (Avalia express√£o)
class EvaluatorVisitor implements ExpressionVisitor {
    private double result;
    
    @Override
    public void visitNumber(NumberExpression number) {
        result = number.getValue();
    }
    
    @Override
    public void visitAddition(AdditionExpression addition) {
        addition.getLeft().accept(this);
        double left = result;
        
        addition.getRight().accept(this);
        double right = result;
        
        result = left + right;
        System.out.printf("   %.2f + %.2f = %.2f\n", left, right, result);
    }
    
    @Override
    public void visitSubtraction(SubtractionExpression subtraction) {
        subtraction.getLeft().accept(this);
        double left = result;
        
        subtraction.getRight().accept(this);
        double right = result;
        
        result = left - right;
        System.out.printf("   %.2f - %.2f = %.2f\n", left, right, result);
    }
    
    @Override
    public void visitMultiplication(MultiplicationExpression multiplication) {
        multiplication.getLeft().accept(this);
        double left = result;
        
        multiplication.getRight().accept(this);
        double right = result;
        
        result = left * right;
        System.out.printf("   %.2f √ó %.2f = %.2f\n", left, right, result);
    }
    
    @Override
    public void visitDivision(DivisionExpression division) {
        division.getLeft().accept(this);
        double left = result;
        
        division.getRight().accept(this);
        double right = result;
        
        if (right == 0) {
            System.out.println("   ‚ùå ERRO: Divis√£o por zero!");
            result = Double.NaN;
        } else {
            result = left / right;
            System.out.printf("   %.2f √∑ %.2f = %.2f\n", left, right, result);
        }
    }
    
    public double getResult() {
        return result;
    }
}

// Concrete Visitor 2 - Impressora (Formato leg√≠vel)
class PrinterVisitor implements ExpressionVisitor {
    private StringBuilder output = new StringBuilder();
    
    @Override
    public void visitNumber(NumberExpression number) {
        output.append(number.getValue());
    }
    
    @Override
    public void visitAddition(AdditionExpression addition) {
        output.append("(");
        addition.getLeft().accept(this);
        output.append(" + ");
        addition.getRight().accept(this);
        output.append(")");
    }
    
    @Override
    public void visitSubtraction(SubtractionExpression subtraction) {
        output.append("(");
        subtraction.getLeft().accept(this);
        output.append(" - ");
        subtraction.getRight().accept(this);
        output.append(")");
    }
    
    @Override
    public void visitMultiplication(MultiplicationExpression multiplication) {
        output.append("(");
        multiplication.getLeft().accept(this);
        output.append(" √ó ");
        multiplication.getRight().accept(this);
        output.append(")");
    }
    
    @Override
    public void visitDivision(DivisionExpression division) {
        output.append("(");
        division.getLeft().accept(this);
        output.append(" √∑ ");
        division.getRight().accept(this);
        output.append(")");
    }
    
    public String getOutput() {
        return output.toString();
    }
    
    public void reset() {
        output = new StringBuilder();
    }
}

// Concrete Visitor 3 - Contador de Opera√ß√µes
class OperationCounterVisitor implements ExpressionVisitor {
    private int numberCount = 0;
    private int additionCount = 0;
    private int subtractionCount = 0;
    private int multiplicationCount = 0;
    private int divisionCount = 0;
    
    @Override
    public void visitNumber(NumberExpression number) {
        numberCount++;
    }
    
    @Override
    public void visitAddition(AdditionExpression addition) {
        additionCount++;
        addition.getLeft().accept(this);
        addition.getRight().accept(this);
    }
    
    @Override
    public void visitSubtraction(SubtractionExpression subtraction) {
        subtractionCount++;
        subtraction.getLeft().accept(this);
        subtraction.getRight().accept(this);
    }
    
    @Override
    public void visitMultiplication(MultiplicationExpression multiplication) {
        multiplicationCount++;
        multiplication.getLeft().accept(this);
        multiplication.getRight().accept(this);
    }
    
    @Override
    public void visitDivision(DivisionExpression division) {
        divisionCount++;
        division.getLeft().accept(this);
        division.getRight().accept(this);
    }
    
    public void printStatistics() {
        System.out.println("\nüìä ESTAT√çSTICAS DA EXPRESS√ÉO:");
        System.out.println("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
        System.out.printf("üî¢ N√∫meros: %d\n", numberCount);
        System.out.printf("‚ûï Adi√ß√µes: %d\n", additionCount);
        System.out.printf("‚ûñ Subtra√ß√µes: %d\n", subtractionCount);
        System.out.printf("‚úñÔ∏è  Multiplica√ß√µes: %d\n", multiplicationCount);
        System.out.printf("‚ûó Divis√µes: %d\n", divisionCount);
        System.out.printf("üìà Total de opera√ß√µes: %d\n",
            additionCount + subtractionCount + multiplicationCount + divisionCount);
        System.out.println("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");
    }
}

// Concrete Visitor 4 - Conversor para c√≥digo
class CodeGeneratorVisitor implements ExpressionVisitor {
    private StringBuilder code = new StringBuilder();
    
    @Override
    public void visitNumber(NumberExpression number) {
        code.append(number.getValue());
    }
    
    @Override
    public void visitAddition(AdditionExpression addition) {
        code.append("add(");
        addition.getLeft().accept(this);
        code.append(", ");
        addition.getRight().accept(this);
        code.append(")");
    }
    
    @Override
    public void visitSubtraction(SubtractionExpression subtraction) {
        code.append("subtract(");
        subtraction.getLeft().accept(this);
        code.append(", ");
        subtraction.getRight().accept(this);
        code.append(")");
    }
    
    @Override
    public void visitMultiplication(MultiplicationExpression multiplication) {
        code.append("multiply(");
        multiplication.getLeft().accept(this);
        code.append(", ");
        multiplication.getRight().accept(this);
        code.append(")");
    }
    
    @Override
    public void visitDivision(DivisionExpression division) {
        code.append("divide(");
        division.getLeft().accept(this);
        code.append(", ");
        division.getRight().accept(this);
        code.append(")");
    }
    
    public String getCode() {
        return code.toString();
    }
    
    public void reset() {
        code = new StringBuilder();
    }
}

// Uso
public class ExpressionAnalysisExample {
    public static void main(String[] args) {
        System.out.println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        System.out.println("   SISTEMA DE AN√ÅLISE DE EXPRESS√ïES");
        System.out.println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        
        // Cria express√£o: ((10 + 5) √ó (20 - 8)) √∑ 4
        Expression expr = new DivisionExpression(
            new MultiplicationExpression(
                new AdditionExpression(
                    new NumberExpression(10),
                    new NumberExpression(5)
                ),
                new SubtractionExpression(
                    new NumberExpression(20),
                    new NumberExpression(8)
                )
            ),
            new NumberExpression(4)
        );
        
        // Visitor 1: Imprimir express√£o
        System.out.println("### EXPRESS√ÉO ###\n");
        PrinterVisitor printer = new PrinterVisitor();
        expr.accept(printer);
        System.out.println("üìù " + printer.getOutput() + "\n");
        
        // Visitor 2: Avaliar express√£o
        System.out.println("### AVALIA√á√ÉO PASSO A PASSO ###\n");
        EvaluatorVisitor evaluator = new EvaluatorVisitor();
        expr.accept(evaluator);
        System.out.println("\nüéØ RESULTADO FINAL: " + evaluator.getResult() + "\n");
        
        // Visitor 3: Estat√≠sticas
        OperationCounterVisitor counter = new OperationCounterVisitor();
        expr.accept(counter);
        counter.printStatistics();
        
        // Visitor 4: Gerar c√≥digo
        System.out.println("\n### GERA√á√ÉO DE C√ìDIGO ###\n");
        CodeGeneratorVisitor codeGen = new CodeGeneratorVisitor();
        expr.accept(codeGen);
        System.out.println("üíª C√≥digo gerado:");
        System.out.println("   " + codeGen.getCode());
        
        // Nova express√£o: (100 √∑ 0) - Teste de divis√£o por zero
        System.out.println("\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        System.out.println("   TESTE: DIVIS√ÉO POR ZERO");
        System.out.println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        
        Expression divByZero = new DivisionExpression(
            new NumberExpression(100),
            new NumberExpression(0)
        );
        
        printer.reset();
        divByZero.accept(printer);
        System.out.println("üìù " + printer.getOutput() + "\n");
        
        EvaluatorVisitor eval2 = new EvaluatorVisitor();
        divByZero.accept(eval2);
        System.out.println("\nüéØ RESULTADO: " + 
            (Double.isNaN(eval2.getResult()) ? "ERRO" : eval2.getResult()));
    }
}
```

## üéØ Quando Usar?

### ‚úÖ Use quando:
- **Opera√ß√£o em estrutura complexa**: Quer executar opera√ß√£o sobre todos elementos (√°rvore de objetos)
- **Muitas opera√ß√µes n√£o relacionadas**: Limpeza de c√≥digo, separando comportamentos auxiliares
- **Comportamento faz sentido em apenas algumas classes**: Da hierarquia
- **Adicionar opera√ß√µes frequentemente**: Sem modificar classes de elementos
- **Estrutura est√°vel, opera√ß√µes mudam**: Hierarquia de elementos raramente muda
- **Double Dispatch necess√°rio**: Precisa resolver tipo em runtime

### üìù Exemplos de aplica√ß√£o:
- **Compiladores**: AST (Abstract Syntax Tree) - an√°lise, otimiza√ß√£o, gera√ß√£o de c√≥digo
- **Export/Import**: XML, JSON, CSV, PDF de estrutura de dados
- **C√°lculos**: Impostos, frete, pre√ßos com regras espec√≠ficas por tipo
- **Report generation**: Diferentes formatos de relat√≥rio
- **Valida√ß√£o**: Regras espec√≠ficas por tipo de elemento
- **Document processing**: Diferentes tipos de n√≥s/elementos

### ‚ùå Evite quando:
- **Hierarquia inst√°vel**: Classes adicionadas/removidas frequentemente
- **Poucas opera√ß√µes**: 1-2 opera√ß√µes n√£o justificam complexidade
- **Opera√ß√µes simples**: Comportamento trivial n√£o precisa visitor
- **Acesso a membros privados**: Visitor precisa acessar estado interno privado

## üöÄ Como Implementar

1. **Declare interface Visitor** com m√©todo "visit" para cada ConcreteElement

2. **Declare interface Element** com m√©todo `accept(Visitor)`

3. **Implemente accept()** em todos ConcreteElements redirecionando para m√©todo visitor apropriado

4. **Elementos trabalham com visitors** via interface Visitor

5. **Crie ConcreteVisitors** implementando todos m√©todos visit

6. **Cliente cria visitor** e passa para elementos via `accept()`

## ‚öñÔ∏è Pr√≥s e Contras

### ‚úÖ Vantagens:
- **Open/Closed Principle**: Novos comportamentos sem modificar elementos
- **Single Responsibility Principle**: M√∫ltiplas vers√µes de comportamento em uma classe
- **Acumula estado**: Visitor pode acumular informa√ß√µes √∫teis durante travessia
- **Separa algoritmos**: Comportamentos ficam em classes visitor separadas
- **Facilita adicionar opera√ß√µes**: Nova opera√ß√£o = novo visitor

### ‚ùå Desvantagens:
- **Atualizar todos visitors**: Quando classe adicionada/removida da hierarquia
- **Quebra encapsulamento**: Visitor pode precisar acessar campos/m√©todos privados
- **Complexidade**: Double dispatch n√£o √© √≥bvio
- **Hierarquia deve ser est√°vel**: Adicionar elemento for√ßa mudan√ßa em todos visitors

## üîó Diferen√ßas de Outros Padr√µes

| Padr√£o | Foco | Quando usar | Modifica√ß√£o |
|--------|------|-------------|-------------|
| **Visitor** | Separar algoritmos de objetos | Estrutura est√°vel, opera√ß√µes mudam | N√£o modifica elementos |
| **Strategy** | Algoritmos intercambi√°veis | Trocar algoritmo em runtime | Modifica comportamento objeto |
| **Command** | Encapsular requisi√ß√£o | Undo/redo, queue, log | Opera√ß√µes como objetos |
| **Iterator** | Acesso sequencial | Percorrer cole√ß√£o | N√£o executa opera√ß√µes |

## üîó Rela√ß√µes com Outros Padr√µes

- **Visitor vs Command**:
  - Visitor: Vers√£o poderosa de Command
  - Visitor pode executar opera√ß√µes sobre objetos de classes diferentes
  - Command: Opera√ß√£o como objeto

- **Visitor + Composite**:
  - Visitor pode executar opera√ß√£o sobre √°rvore Composite inteira
  - Composite fornece estrutura, Visitor percorre e opera

- **Visitor + Iterator**:
  - Visitor percorre estrutura complexa
  - Iterator fornece acesso aos elementos
  - Visitor executa opera√ß√£o, mesmo se classes diferentes

## üìö Conceitos-Chave para Lembrar

1. **Separa√ß√£o de algoritmos**: Comportamentos em classes visitor separadas
2. **Double Dispatch**: Duas chamadas polim√≥rficas resolvem tipo
3. **M√©todo accept()**: Elementos aceitam visitor e delegam chamada
4. **Open/Closed**: Adiciona opera√ß√µes sem modificar elementos
5. **Estrutura est√°vel**: Funciona melhor quando hierarquia de elementos √© est√°vel
6. **Quebra encapsulamento**: Trade-off de expor estado interno

## üîç Analogia do Mundo Real

**Agente de seguros experiente**: Ele visita cada pr√©dio de um bairro tentando vender seguros. Dependendo do tipo de organiza√ß√£o no pr√©dio, ele oferece ap√≥lices especializadas:
- **Residencial**: Vende seguro m√©dico
- **Banco**: Vende seguro contra roubo
- **Cafeteria**: Vende seguro contra inc√™ndio e inunda√ß√£o

O agente (visitor) adapta sua abordagem (opera√ß√£o) baseado no tipo de organiza√ß√£o (elemento) que ele visita. As organiza√ß√µes "aceitam" a visita permitindo que o agente fa√ßa sua proposta espec√≠fica.

## ‚ö†Ô∏è Considera√ß√µes Importantes

### Double Dispatch explicado:

```java
// SEM Visitor - Type checking manual
for (Shape shape : shapes) {
    if (shape instanceof Circle) {
        exportCircle((Circle) shape);
    } else if (shape instanceof Rectangle) {
        exportRectangle((Rectangle) shape);
    }
}

// COM Visitor - Double Dispatch
// 1¬™ dispatch: shape.accept() - polimorfismo baseado em tipo de shape
// 2¬™ dispatch: visitor.visitCircle(this) - polimorfismo baseado em tipo do visitor

for (Shape shape : shapes) {
    shape.accept(exportVisitor); // SEM type checking!
}

// Circle
public void accept(Visitor v) {
    v.visitCircle(this); // Circle SABE que √© Circle
}

// Rectangle
public void accept(Visitor v) {
    v.visitRectangle(this); // Rectangle SABE que √© Rectangle
}
```

### Visitor com Composite (caso comum):

```java
// Composite Element
class CompoundShape implements Shape {
    private List<Shape> children = new ArrayList<>();
    
    @Override
    public void accept(Visitor visitor) {
        // Visita a si mesmo
        visitor.visitCompoundShape(this);
        
        // Visita todos filhos
        for (Shape child : children) {
            child.accept(visitor);
        }
    }
}

// Visitor percorre √°rvore inteira automaticamente
XMLExportVisitor visitor = new XMLExportVisitor();
compoundShape.accept(visitor); // Percorre toda √°rvore!
```

### Problema de acesso a membros privados:

```java
// ‚ùå PROBLEMA: Visitor precisa de dados privados
class Product {
    private double cost;        // Privado
    private double markup;      // Privado
    
    public void accept(Visitor v) {
        v.visitProduct(this);
    }
}

class PriceCalculator implements Visitor {
    public void visitProduct(Product p) {
        // ‚ùå N√£o consegue acessar cost e markup!
        // double price = p.cost * (1 + p.markup);
    }
}

// ‚úÖ SOLU√á√ÉO 1: Adicionar getters (quebra encapsulamento)
class Product {
    private double cost;
    private double markup;
    
    public double getCost() { return cost; }
    public double getMarkup() { return markup; }
}

// ‚úÖ SOLU√á√ÉO 2: Nested class (se linguagem suporta)
class Product {
    private double cost;
    private double markup;
    
    // Visitor interno tem acesso a membros privados
    public static class ProductVisitor implements Visitor {
        public void visitProduct(Product p) {
            double price = p.cost * (1 + p.markup); // OK!
        }
    }
}
```

### Visitor retornando valores:

```java
// Visitor tradicional n√£o retorna valor
interface Visitor {
    void visitElement(Element e);
}

// Visitor gen√©rico com retorno
interface Visitor<T> {
    T visitElement(Element e);
}

class AreaCalculator implements Visitor<Double> {
    @Override
    public Double visitCircle(Circle c) {
        return Math.PI * c.getRadius() * c.getRadius();
    }
    
    @Override
    public Double visitRectangle(Rectangle r) {
        return r.getWidth() * r.getHeight();
    }
}

// Uso
Double area = shape.accept(areaCalculator);
```

### Design Guidelines:
- **Interface est√°vel**: Hierarquia de elementos deve ser est√°vel
- **Visitors mudam**: Adicionar novos visitors deve ser f√°cil
- **Um m√©todo por tipo**: Visitor tem um m√©todo para cada ConcreteElement
- **Sem null checks**: Todos visitors devem implementar todos m√©todos
- **Estado no visitor**: Visitor pode acumular estado durante visitas
- **Composite-friendly**: Funciona muito bem com √°rvores/composites
- **Accept em todos**: Todos ConcreteElements devem implementar accept()

---

> **üí° Dica de Estudo:** Visitor √© como um inspetor de sa√∫de que visita diferentes estabelecimentos (restaurante, padaria, mercado). Ele executa inspe√ß√µes (opera√ß√£o) espec√≠ficas para cada tipo, mas os estabelecimentos n√£o precisam saber como fazer inspe√ß√£o - apenas "aceitam" o inspetor e ele sabe o que verificar em cada lugar!

> **üîë Conceito-chave:** Double Dispatch = elemento conhece seu tipo ‚Üí chama m√©todo visitor espec√≠fico ‚Üí visitor executa opera√ß√£o apropriada. Sem if/instanceof!

> **üìñ Refer√™ncia:** [Refactoring Guru - Visitor](https://refactoring.guru/design-patterns/visitor)
