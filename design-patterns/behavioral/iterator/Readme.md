# Iterator

## üéØ Inten√ß√£o

O Iterator √© um padr√£o de projeto comportamental que permite percorrer elementos de uma cole√ß√£o sem expor sua representa√ß√£o subjacente (lista, pilha, √°rvore, etc.). Ele fornece uma maneira uniforme de acessar elementos sequencialmente sem conhecer os detalhes internos da estrutura de dados.

## üö© Problema

Cole√ß√µes s√£o um dos tipos de dados mais usados em programa√ß√£o. Uma cole√ß√£o √© apenas um cont√™iner para um grupo de objetos. A maioria das cole√ß√µes armazena seus elementos em listas simples, mas algumas s√£o baseadas em pilhas, √°rvores, grafos e outras estruturas de dados complexas.

### Resultado problem√°tico:
```java
// Cliente precisa conhecer estrutura interna
class Client {
    public void processArrayList(ArrayList<Item> items) {
        for (int i = 0; i < items.size(); i++) {
            Item item = items.get(i);
            process(item);
        }
    }
    
    public void processTree(TreeNode root) {
        // Precisa saber como percorrer √°rvore
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            process(node.getData());
            // Adiciona filhos...
        }
    }
    
    public void processGraph(Graph graph) {
        // Precisa implementar BFS/DFS
        Queue<Node> queue = new LinkedList<>();
        Set<Node> visited = new HashSet<>();
        // Algoritmo complexo...
    }
}
```

**Problemas:**
- **Acoplamento alto**: Cliente conhece estrutura interna da cole√ß√£o
- **C√≥digo duplicado**: L√≥gica de travessia repetida em v√°rios lugares
- **Dif√≠cil manuten√ß√£o**: Mudan√ßas na estrutura afetam todo c√≥digo cliente
- **Sem uniformidade**: Cada cole√ß√£o tem interface diferente
- **Responsabilidades misturadas**: Cole√ß√£o acumula l√≥gica de travessia
- **Imposs√≠vel m√∫ltiplas travessias**: N√£o d√° para percorrer a mesma cole√ß√£o de formas diferentes simultaneamente

## ‚úÖ Solu√ß√£o

A ideia principal do padr√£o Iterator √© extrair o comportamento de travessia de uma cole√ß√£o para um objeto separado chamado **iterator**. Al√©m de implementar o algoritmo, um iterator encapsula todos os detalhes da travessia, como a posi√ß√£o atual e quantos elementos faltam at√© o fim.

### Caracter√≠sticas-chave:
- **Encapsulamento**: Esconde detalhes da travessia
- **Interface uniforme**: Mesma interface para todas cole√ß√µes
- **M√∫ltiplos iterators**: V√°rios podem percorrer a mesma cole√ß√£o
- **Independ√™ncia**: Iterators mant√©m estado pr√≥prio
- **Desacoplamento**: Cliente independente da estrutura
- **Travessias variadas**: Diferentes algoritmos de percurso

```java
// Interface Iterator
interface Iterator<T> {
    boolean hasNext();
    T next();
}

// Interface Collection
interface Collection<T> {
    Iterator<T> createIterator();
}

// Cliente usa interface uniforme
void processCollection(Collection<Item> collection) {
    Iterator<Item> iterator = collection.createIterator();
    while (iterator.hasNext()) {
        Item item = iterator.next();
        process(item);
    }
}

// Funciona com qualquer cole√ß√£o!
processCollection(new ArrayList<>());
processCollection(new TreeCollection<>());
processCollection(new GraphCollection<>());
```

## üèóÔ∏è Estrutura

```
Client ‚Üí Collection (interface) ‚Üê ConcreteCollection
              ‚Üì                           ‚Üì
       createIterator()            createIterator()
              ‚Üì                           ‚Üì
         Iterator (interface) ‚Üê ConcreteIterator
              ‚Üì                           ‚Üì
         hasNext()                   [traversal state]
         next()                      [current position]
```

### Componentes:
- **Iterator**: Interface que declara opera√ß√µes para travessia
- **ConcreteIterator**: Implementa algoritmo espec√≠fico de travessia
- **Collection**: Interface que declara m√©todo para criar iterator
- **ConcreteCollection**: Retorna inst√¢ncia de iterator apropriado
- **Client**: Trabalha com cole√ß√µes e iterators via interfaces

## üíª Exemplos Pr√°ticos

### Exemplo 1: Cole√ß√£o de Livros com Diferentes Travessias

```java
// Classe do item
class Book {
    private String title;
    private String author;
    private String genre;
    private int year;
    
    public Book(String title, String author, String genre, int year) {
        this.title = title;
        this.author = author;
        this.genre = genre;
        this.year = year;
    }
    
    // Getters
    public String getTitle() { return title; }
    public String getAuthor() { return author; }
    public String getGenre() { return genre; }
    public int getYear() { return year; }
    
    @Override
    public String toString() {
        return String.format("\"%s\" por %s (%d) - %s", title, author, year, genre);
    }
}

// Interface Iterator
interface BookIterator {
    boolean hasNext();
    Book next();
}

// Interface Collection
interface BookCollection {
    BookIterator createIterator();
    BookIterator createReverseIterator();
    BookIterator createGenreIterator(String genre);
}

// Iterator por ordem normal
class NormalIterator implements BookIterator {
    private List<Book> books;
    private int position;
    
    public NormalIterator(List<Book> books) {
        this.books = books;
        this.position = 0;
    }
    
    @Override
    public boolean hasNext() {
        return position < books.size();
    }
    
    @Override
    public Book next() {
        if (!hasNext()) {
            throw new NoSuchElementException("N√£o h√° mais elementos");
        }
        return books.get(position++);
    }
}

// Iterator por ordem reversa
class ReverseIterator implements BookIterator {
    private List<Book> books;
    private int position;
    
    public ReverseIterator(List<Book> books) {
        this.books = books;
        this.position = books.size() - 1;
    }
    
    @Override
    public boolean hasNext() {
        return position >= 0;
    }
    
    @Override
    public Book next() {
        if (!hasNext()) {
            throw new NoSuchElementException("N√£o h√° mais elementos");
        }
        return books.get(position--);
    }
}

// Iterator filtrado por g√™nero
class GenreIterator implements BookIterator {
    private List<Book> books;
    private String genre;
    private int position;
    
    public GenreIterator(List<Book> books, String genre) {
        this.books = books;
        this.genre = genre;
        this.position = 0;
    }
    
    @Override
    public boolean hasNext() {
        while (position < books.size()) {
            if (books.get(position).getGenre().equalsIgnoreCase(genre)) {
                return true;
            }
            position++;
        }
        return false;
    }
    
    @Override
    public Book next() {
        if (!hasNext()) {
            throw new NoSuchElementException("N√£o h√° mais elementos");
        }
        return books.get(position++);
    }
}

// Cole√ß√£o concreta
class Library implements BookCollection {
    private List<Book> books;
    
    public Library() {
        this.books = new ArrayList<>();
    }
    
    public void addBook(Book book) {
        books.add(book);
        System.out.println("üìö Livro adicionado: " + book.getTitle());
    }
    
    @Override
    public BookIterator createIterator() {
        return new NormalIterator(books);
    }
    
    @Override
    public BookIterator createReverseIterator() {
        return new ReverseIterator(books);
    }
    
    @Override
    public BookIterator createGenreIterator(String genre) {
        return new GenreIterator(books, genre);
    }
    
    public int size() {
        return books.size();
    }
}

// Cliente que usa iterators
class LibraryReader {
    public void readAllBooks(Library library) {
        System.out.println("\n=== Lendo todos os livros (ordem normal) ===");
        BookIterator iterator = library.createIterator();
        int count = 1;
        
        while (iterator.hasNext()) {
            Book book = iterator.next();
            System.out.println(count++ + ". " + book);
        }
    }
    
    public void readBooksReverse(Library library) {
        System.out.println("\n=== Lendo livros (ordem reversa) ===");
        BookIterator iterator = library.createReverseIterator();
        int count = 1;
        
        while (iterator.hasNext()) {
            Book book = iterator.next();
            System.out.println(count++ + ". " + book);
        }
    }
    
    public void readBooksByGenre(Library library, String genre) {
        System.out.println("\n=== Lendo livros de " + genre + " ===");
        BookIterator iterator = library.createGenreIterator(genre);
        int count = 1;
        
        while (iterator.hasNext()) {
            Book book = iterator.next();
            System.out.println(count++ + ". " + book);
        }
    }
    
    public void demonstrateMultipleIterators(Library library) {
        System.out.println("\n=== M√∫ltiplos iterators simult√¢neos ===");
        
        BookIterator iter1 = library.createIterator();
        BookIterator iter2 = library.createIterator();
        
        System.out.println("Iterator 1 (primeiro livro): " + iter1.next().getTitle());
        System.out.println("Iterator 2 (primeiro livro): " + iter2.next().getTitle());
        System.out.println("Iterator 1 (segundo livro): " + iter1.next().getTitle());
        System.out.println("Iterator 2 (segundo livro): " + iter2.next().getTitle());
        
        System.out.println("\n‚úÖ Cada iterator mant√©m seu pr√≥prio estado!");
    }
}

// Uso
public class LibraryExample {
    public static void main(String[] args) {
        Library library = new Library();
        
        // Adiciona livros
        System.out.println("=== Montando biblioteca ===");
        library.addBook(new Book("1984", "George Orwell", "Fic√ß√£o", 1949));
        library.addBook(new Book("O Senhor dos An√©is", "J.R.R. Tolkien", "Fantasia", 1954));
        library.addBook(new Book("Harry Potter", "J.K. Rowling", "Fantasia", 1997));
        library.addBook(new Book("Clean Code", "Robert Martin", "T√©cnico", 2008));
        library.addBook(new Book("O Hobbit", "J.R.R. Tolkien", "Fantasia", 1937));
        
        System.out.println("\nüìñ Total de livros: " + library.size());
        
        // Usa diferentes iterators
        LibraryReader reader = new LibraryReader();
        
        reader.readAllBooks(library);
        reader.readBooksReverse(library);
        reader.readBooksByGenre(library, "Fantasia");
        reader.demonstrateMultipleIterators(library);
    }
}
```

### Exemplo 2: √Årvore com Diferentes Estrat√©gias de Travessia

```java
// N√≥ da √°rvore
class TreeNode<T> {
    private T data;
    private TreeNode<T> left;
    private TreeNode<T> right;
    
    public TreeNode(T data) {
        this.data = data;
    }
    
    public void setLeft(TreeNode<T> left) { this.left = left; }
    public void setRight(TreeNode<T> right) { this.right = right; }
    public T getData() { return data; }
    public TreeNode<T> getLeft() { return left; }
    public TreeNode<T> getRight() { return right; }
}

// Interface Iterator
interface TreeIterator<T> {
    boolean hasNext();
    T next();
}

// Interface Collection
interface Tree<T> {
    TreeIterator<T> createInOrderIterator();
    TreeIterator<T> createPreOrderIterator();
    TreeIterator<T> createPostOrderIterator();
    TreeIterator<T> createBreadthFirstIterator();
}

// Iterator In-Order (esquerda, raiz, direita)
class InOrderIterator<T> implements TreeIterator<T> {
    private Stack<TreeNode<T>> stack;
    
    public InOrderIterator(TreeNode<T> root) {
        stack = new Stack<>();
        pushLeftChildren(root);
    }
    
    private void pushLeftChildren(TreeNode<T> node) {
        while (node != null) {
            stack.push(node);
            node = node.getLeft();
        }
    }
    
    @Override
    public boolean hasNext() {
        return !stack.isEmpty();
    }
    
    @Override
    public T next() {
        if (!hasNext()) {
            throw new NoSuchElementException();
        }
        
        TreeNode<T> node = stack.pop();
        T data = node.getData();
        
        if (node.getRight() != null) {
            pushLeftChildren(node.getRight());
        }
        
        return data;
    }
}

// Iterator Pre-Order (raiz, esquerda, direita)
class PreOrderIterator<T> implements TreeIterator<T> {
    private Stack<TreeNode<T>> stack;
    
    public PreOrderIterator(TreeNode<T> root) {
        stack = new Stack<>();
        if (root != null) {
            stack.push(root);
        }
    }
    
    @Override
    public boolean hasNext() {
        return !stack.isEmpty();
    }
    
    @Override
    public T next() {
        if (!hasNext()) {
            throw new NoSuchElementException();
        }
        
        TreeNode<T> node = stack.pop();
        
        // Push direita primeiro (ser√° processada depois)
        if (node.getRight() != null) {
            stack.push(node.getRight());
        }
        if (node.getLeft() != null) {
            stack.push(node.getLeft());
        }
        
        return node.getData();
    }
}

// Iterator Breadth-First (por n√≠vel)
class BreadthFirstIterator<T> implements TreeIterator<T> {
    private Queue<TreeNode<T>> queue;
    
    public BreadthFirstIterator(TreeNode<T> root) {
        queue = new LinkedList<>();
        if (root != null) {
            queue.offer(root);
        }
    }
    
    @Override
    public boolean hasNext() {
        return !queue.isEmpty();
    }
    
    @Override
    public T next() {
        if (!hasNext()) {
            throw new NoSuchElementException();
        }
        
        TreeNode<T> node = queue.poll();
        
        if (node.getLeft() != null) {
            queue.offer(node.getLeft());
        }
        if (node.getRight() != null) {
            queue.offer(node.getRight());
        }
        
        return node.getData();
    }
}

// √Årvore bin√°ria concreta
class BinaryTree<T> implements Tree<T> {
    private TreeNode<T> root;
    
    public void setRoot(TreeNode<T> root) {
        this.root = root;
    }
    
    public TreeNode<T> getRoot() {
        return root;
    }
    
    @Override
    public TreeIterator<T> createInOrderIterator() {
        return new InOrderIterator<>(root);
    }
    
    @Override
    public TreeIterator<T> createPreOrderIterator() {
        return new PreOrderIterator<>(root);
    }
    
    @Override
    public TreeIterator<T> createPostOrderIterator() {
        // Implementa√ß√£o similar...
        throw new UnsupportedOperationException("Post-order n√£o implementado neste exemplo");
    }
    
    @Override
    public TreeIterator<T> createBreadthFirstIterator() {
        return new BreadthFirstIterator<>(root);
    }
}

// Cliente
class TreeTraverser {
    public <T> void traverse(String type, TreeIterator<T> iterator) {
        System.out.println("\n=== Travessia " + type + " ===");
        System.out.print("Elementos: ");
        
        while (iterator.hasNext()) {
            System.out.print(iterator.next() + " ");
        }
        System.out.println();
    }
}

// Uso
public class TreeExample {
    public static void main(String[] args) {
        // Cria √°rvore:
        //        1
        //       / \
        //      2   3
        //     / \   \
        //    4   5   6
        
        BinaryTree<Integer> tree = new BinaryTree<>();
        
        TreeNode<Integer> root = new TreeNode<>(1);
        TreeNode<Integer> node2 = new TreeNode<>(2);
        TreeNode<Integer> node3 = new TreeNode<>(3);
        TreeNode<Integer> node4 = new TreeNode<>(4);
        TreeNode<Integer> node5 = new TreeNode<>(5);
        TreeNode<Integer> node6 = new TreeNode<>(6);
        
        root.setLeft(node2);
        root.setRight(node3);
        node2.setLeft(node4);
        node2.setRight(node5);
        node3.setRight(node6);
        
        tree.setRoot(root);
        
        System.out.println("=== √Årvore Bin√°ria ===");
        System.out.println("       1");
        System.out.println("      / \\");
        System.out.println("     2   3");
        System.out.println("    / \\   \\");
        System.out.println("   4   5   6");
        
        TreeTraverser traverser = new TreeTraverser();
        
        // Diferentes travessias
        traverser.traverse("In-Order (ESQ-RAIZ-DIR)", 
            tree.createInOrderIterator());
        
        traverser.traverse("Pre-Order (RAIZ-ESQ-DIR)", 
            tree.createPreOrderIterator());
        
        traverser.traverse("Breadth-First (Por N√≠vel)", 
            tree.createBreadthFirstIterator());
        
        // Demonstra m√∫ltiplos iterators
        System.out.println("\n=== M√∫ltiplos Iterators Simult√¢neos ===");
        TreeIterator<Integer> iter1 = tree.createInOrderIterator();
        TreeIterator<Integer> iter2 = tree.createPreOrderIterator();
        
        System.out.println("In-Order primeiro: " + iter1.next());
        System.out.println("Pre-Order primeiro: " + iter2.next());
        System.out.println("In-Order segundo: " + iter1.next());
        System.out.println("Pre-Order segundo: " + iter2.next());
    }
}
```

## üéØ Quando Usar?

### ‚úÖ Use quando:
- **Estrutura complexa**: Cole√ß√£o tem estrutura interna complexa
- **Ocultar complexidade**: N√£o quer expor detalhes aos clientes
- **Reduzir duplica√ß√£o**: Travessia repetida em v√°rios lugares
- **M√∫ltiplas travessias**: Diferentes formas de percorrer
- **Desconhecimento pr√©vio**: Tipos de estruturas desconhecidos
- **Interface uniforme**: Quer tratar cole√ß√µes uniformemente

### üìù Exemplos de aplica√ß√£o:
- **Collections Framework**: Java Iterator, C# IEnumerator
- **DOM Tree**: Document traversal
- **File Systems**: Directory iteration
- **Graph algorithms**: BFS, DFS iterators
- **Database cursors**: Result set iteration

### ‚ùå Evite quando:
- **Cole√ß√µes simples**: Array ou lista simples j√° basta
- **Acesso aleat√≥rio**: Precisa de acesso direto por √≠ndice
- **Performance cr√≠tica**: Overhead de objetos pode impactar

## üöÄ Como Implementar

1. **Declare interface Iterator** com m√©todos `hasNext()` e `next()`

2. **Declare interface Collection** com m√©todo `createIterator()`

3. **Implemente iterators concretos** para cada cole√ß√£o

4. **Implemente interface Collection** nas classes de cole√ß√£o

5. **Cliente usa iterators** ao inv√©s de acessar cole√ß√£o diretamente

6. **Considere iterators bidirecionais** se necess√°rio (previous())

## ‚öñÔ∏è Pr√≥s e Contras

### ‚úÖ Vantagens:
- **Single Responsibility**: Separa travessia de cole√ß√£o
- **Open/Closed**: Novos iterators sem mudar c√≥digo
- **Itera√ß√£o paralela**: M√∫ltiplos iterators independentes
- **Itera√ß√£o diferida**: Pode pausar e continuar depois
- **Interface uniforme**: Mesmo c√≥digo para diferentes cole√ß√µes

### ‚ùå Desvantagens:
- **Overkill**: Para cole√ß√µes simples pode ser excessivo
- **Performance**: Menos eficiente que acesso direto
- **Complexidade**: Mais classes e interfaces

## üîó Diferen√ßas de Outros Padr√µes

| Padr√£o | Foco | Travessia | Estado |
|--------|------|-----------|--------|
| **Iterator** | Percorrer cole√ß√£o | Externa (cliente controla) | Mant√©m posi√ß√£o |
| **Visitor** | Opera√ß√£o em elementos | Interna (visitor percorre) | Stateless |
| **Composite** | Estrutura √°rvore | Recursiva | Hier√°rquica |
| **Strategy** | Algoritmo vari√°vel | N/A | Algoritmo encapsulado |

## üîó Rela√ß√µes com Outros Padr√µes

- **Composite**: Iterators podem percorrer √°rvores Composite
- **Factory Method**: Cole√ß√µes podem usar Factory para criar iterators
- **Memento**: Pode salvar estado da itera√ß√£o
- **Visitor**: Visitor percorre estrutura, Iterator d√° acesso aos elementos

## üìö Conceitos-Chave para Lembrar

1. **Separa√ß√£o de responsabilidades**: Cole√ß√£o armazena, iterator percorre
2. **Interface uniforme**: Mesma interface para todas cole√ß√µes
3. **Estado independente**: Cada iterator mant√©m posi√ß√£o pr√≥pria
4. **M√∫ltiplas travessias**: V√°rios iterators na mesma cole√ß√£o
5. **Encapsulamento**: Oculta estrutura interna da cole√ß√£o
6. **Travessias variadas**: Diferentes algoritmos de percurso

## üîç Analogia do Mundo Real

**Guia tur√≠stico em Roma**: Voc√™ pode explorar Roma de v√°rias formas - caminhando aleatoriamente (acesso direto), usando app de navega√ß√£o (iterator simples), ou contratando guia local (iterator especializado). Cada forma de percorrer a cidade √© um iterator diferente sobre a mesma cole√ß√£o (pontos tur√≠sticos de Roma). O guia conhece a estrutura (ruas, trajetos) mas voc√™ s√≥ v√™ os pontos tur√≠sticos em sequ√™ncia.

## ‚ö†Ô∏è Considera√ß√µes Importantes

### Iterator em Java:
```java
// Java fornece interface Iterator padr√£o
interface Iterator<E> {
    boolean hasNext();
    E next();
    default void remove() {
        throw new UnsupportedOperationException();
    }
}

// E interface Iterable para cole√ß√µes
interface Iterable<E> {
    Iterator<E> iterator();
}

// Uso com enhanced for
for (Item item : collection) {
    // Usa iterator internamente
}
```

### Iterator externo vs interno:

#### Externo (External Iterator)
```java
// Cliente controla itera√ß√£o
Iterator<Item> iter = collection.iterator();
while (iter.hasNext()) {
    Item item = iter.next();
    process(item);
}
```

#### Interno (Internal Iterator)
```java
// Cole√ß√£o controla itera√ß√£o
collection.forEach(item -> process(item));
```

### Fail-fast iterators:
```java
// Lan√ßa ConcurrentModificationException se cole√ß√£o mudar
List<String> list = new ArrayList<>();
list.add("A");
list.add("B");

Iterator<String> iter = list.iterator();
iter.next();
list.add("C"); // Modifica durante itera√ß√£o
iter.next(); // ‚ùå Lan√ßa exce√ß√£o!
```

### Design Guidelines:
- **Imutabilidade**: Iterator n√£o deve modificar cole√ß√£o
- **Fail-fast**: Detecte modifica√ß√µes concorrentes
- **Lazy evaluation**: Calcule elementos sob demanda se poss√≠vel
- **Resource cleanup**: Feche recursos ao finalizar itera√ß√£o

---

> **üí° Dica de Estudo:** Iterator √© como um "controle remoto" para sua TV (cole√ß√£o) - voc√™ aperta os bot√µes (hasNext/next) sem precisar saber como a TV funciona internamente. Diferentes controles remotos (iterators) podem ter fun√ß√µes diferentes, mas todos controlam a mesma TV.

> **üìñ Refer√™ncia:** [Refactoring Guru - Iterator](https://refactoring.guru/design-patterns/iterator)
