# Adapter

> **Tamb√©m conhecido como:** Wrapper

## üéØ Inten√ß√£o

O Adapter √© um padr√£o de projeto estrutural que permite que objetos com interfaces incompat√≠veis colaborem entre si. Ele atua como um "tradutor" entre duas interfaces diferentes.

## üö© Problema

Imagine que voc√™ est√° criando uma aplica√ß√£o de monitoramento do mercado de a√ß√µes. A aplica√ß√£o baixa dados de m√∫ltiplas fontes em formato XML e exibe gr√°ficos bonitos para o usu√°rio.

Em determinado momento, voc√™ decide melhorar a aplica√ß√£o integrando uma biblioteca de an√°lise inteligente de terceiros. **Mas h√° um problema**: a biblioteca s√≥ funciona com dados em formato JSON.

### Dilemas comuns:
- **Interface incompat√≠vel**: Sua aplica√ß√£o usa XML, a biblioteca usa JSON
- **N√£o pode modificar a biblioteca**: C√≥digo de terceiros ou sem acesso ao fonte
- **Modificar sua aplica√ß√£o**: Pode quebrar funcionalidades existentes

```java
// Sua aplica√ß√£o trabalha com XML
XMLData xmlData = getStockDataXML();

// Biblioteca espera JSON
AnalyticsLibrary library = new AnalyticsLibrary();
library.analyze(jsonData); // ‚ùå N√£o funciona com XML
```

## ‚úÖ Solu√ß√£o

Voc√™ pode criar um **adapter** - um objeto especial que converte a interface de um objeto para que outro objeto possa entend√™-lo.

**Como funciona:**
1. O adapter implementa uma interface compat√≠vel com um dos objetos existentes
2. O objeto existente pode chamar m√©todos do adapter com seguran√ßa
3. Ao receber uma chamada, o adapter passa a requisi√ß√£o para o segundo objeto no formato esperado

**Vantagens do Adapter:**
- Esconde a complexidade da convers√£o
- O objeto adaptado n√£o sabe da exist√™ncia do adapter
- Pode criar adapters bidirecionais

## üèóÔ∏è Estrutura

### Object Adapter (Composi√ß√£o):
```
Client ‚Üí ClientInterface ‚Üê Adapter ‚Üí Service
                              ‚Üì
                         (wraps/contains)
```

### Class Adapter (Heran√ßa):
```
Client ‚Üí Adapter extends Service implements ClientInterface
```

### Componentes:
- **Client**: Classe com l√≥gica de neg√≥cio existente
- **ClientInterface**: Protocolo que outras classes devem seguir
- **Service**: Classe √∫til (3¬™ parte/legacy) com interface incompat√≠vel
- **Adapter**: Trabalha com client e service, traduzindo chamadas

## üíª Exemplo Pr√°tico

### Cen√°rio: Sistema de Pagamento

```java
// Interface esperada pelo nosso sistema
interface PaymentProcessor {
    void processPayment(double amount, String currency);
    boolean validatePayment(String details);
}

// Nossa implementa√ß√£o interna
class InternalPaymentProcessor implements PaymentProcessor {
    @Override
    public void processPayment(double amount, String currency) {
        System.out.printf("Processando pagamento interno: %.2f %s%n", amount, currency);
    }
    
    @Override
    public boolean validatePayment(String details) {
        return details != null && !details.isEmpty();
    }
}

// Biblioteca externa de pagamento (interface incompat√≠vel)
class ExternalPaymentGateway {
    public void makePayment(int amountInCents, String currencyCode, String metadata) {
        System.out.printf("Gateway externo: %d centavos %s [%s]%n", 
                         amountInCents, currencyCode, metadata);
    }
    
    public boolean checkTransaction(String transactionInfo) {
        return transactionInfo.contains("VALID");
    }
}

// Adapter para compatibilizar as interfaces
class PaymentGatewayAdapter implements PaymentProcessor {
    private ExternalPaymentGateway externalGateway;
    
    public PaymentGatewayAdapter(ExternalPaymentGateway gateway) {
        this.externalGateway = gateway;
    }
    
    @Override
    public void processPayment(double amount, String currency) {
        // Converte valores para o formato esperado pela biblioteca externa
        int amountInCents = (int) (amount * 100);
        String metadata = "Processed by adapter";
        
        externalGateway.makePayment(amountInCents, currency, metadata);
    }
    
    @Override
    public boolean validatePayment(String details) {
        // Adapta a valida√ß√£o para o formato da biblioteca externa
        String transactionInfo = "VALID:" + details;
        return externalGateway.checkTransaction(transactionInfo);
    }
}

// Sistema de pagamentos que usa a interface padr√£o
class PaymentSystem {
    private PaymentProcessor processor;
    
    public PaymentSystem(PaymentProcessor processor) {
        this.processor = processor;
    }
    
    public void processOrder(double amount, String currency, String details) {
        if (processor.validatePayment(details)) {
            processor.processPayment(amount, currency);
            System.out.println("Pagamento processado com sucesso!");
        } else {
            System.out.println("Falha na valida√ß√£o do pagamento");
        }
    }
}

// Uso
public class AdapterExample {
    public static void main(String[] args) {
        // Usando processador interno
        PaymentSystem system1 = new PaymentSystem(new InternalPaymentProcessor());
        system1.processOrder(99.99, "USD", "ORDER123");
        
        System.out.println();
        
        // Usando biblioteca externa atrav√©s do adapter
        ExternalPaymentGateway externalGateway = new ExternalPaymentGateway();
        PaymentGatewayAdapter adapter = new PaymentGatewayAdapter(externalGateway);
        
        PaymentSystem system2 = new PaymentSystem(adapter);
        system2.processOrder(149.50, "EUR", "ORDER456");
    }
}
```

### Exemplo: Media Player

```java
// Interface que nosso sistema entende
interface MediaPlayer {
    void play(String audioType, String fileName);
}

// Player interno b√°sico
class AudioPlayer implements MediaPlayer {
    @Override
    public void play(String audioType, String fileName) {
        if ("mp3".equals(audioType)) {
            System.out.println("Tocando MP3: " + fileName);
        } else {
            System.out.println("Formato n√£o suportado: " + audioType);
        }
    }
}

// Players externos avan√ßados (interfaces incompat√≠veis)
class Mp4Player {
    public void playMp4(String fileName) {
        System.out.println("Tocando MP4: " + fileName);
    }
}

class VlcPlayer {
    public void playVlc(String fileName) {
        System.out.println("Tocando VLC: " + fileName);
    }
}

// Adapter para players externos
class MediaAdapter implements MediaPlayer {
    private Mp4Player mp4Player;
    private VlcPlayer vlcPlayer;
    
    public MediaAdapter(String audioType) {
        if ("mp4".equals(audioType)) {
            mp4Player = new Mp4Player();
        } else if ("vlc".equals(audioType)) {
            vlcPlayer = new VlcPlayer();
        }
    }
    
    @Override
    public void play(String audioType, String fileName) {
        if ("mp4".equals(audioType)) {
            mp4Player.playMp4(fileName);
        } else if ("vlc".equals(audioType)) {
            vlcPlayer.playVlc(fileName);
        }
    }
}

// Player principal com adapter integrado
class AdvancedMediaPlayer implements MediaPlayer {
    private MediaAdapter mediaAdapter;
    
    @Override
    public void play(String audioType, String fileName) {
        if ("mp3".equals(audioType)) {
            System.out.println("Tocando MP3: " + fileName);
        } else if ("mp4".equals(audioType) || "vlc".equals(audioType)) {
            mediaAdapter = new MediaAdapter(audioType);
            mediaAdapter.play(audioType, fileName);
        } else {
            System.out.println("Formato n√£o suportado: " + audioType);
        }
    }
}
```

## üéØ Quando Usar?

### ‚úÖ Use quando:
- **Interface incompat√≠vel**: Quer usar classe existente com interface diferente
- **Classe de terceiros**: Biblioteca externa com interface n√£o compat√≠vel
- **C√≥digo legado**: Sistema antigo que precisa se integrar com novo
- **M√∫ltiplas subclasses**: Precisam de funcionalidade comum que n√£o pode ser adicionada √† superclasse

### üìù Exemplos de uso:
- **Integra√ß√£o de APIs**: Adaptar diferentes APIs de pagamento
- **Sistemas legados**: Integrar sistemas antigos com novos
- **Bibliotecas de terceiros**: Usar bibliotecas com interfaces diferentes
- **Conversores de dados**: XML para JSON, diferentes formatos

### ‚ùå Evite quando:
- **Pode modificar o c√≥digo fonte**: √â mais simples alterar diretamente
- **Interface j√° √© compat√≠vel**: N√£o h√° necessidade de adapta√ß√£o
- **Complexidade desnecess√°ria**: Para casos muito simples

## üöÄ Como Implementar

1. **Identifique classes incompat√≠veis**:
   - Classe de servi√ßo √∫til (n√£o pode alterar)
   - Classes cliente que se beneficiariam do servi√ßo

2. **Declare interface do cliente** e como clientes se comunicam com o servi√ßo

3. **Crie classe adapter** seguindo a interface do cliente

4. **Adicione campo para refer√™ncia** ao objeto de servi√ßo

5. **Implemente m√©todos da interface** no adapter:
   - Delegue trabalho real para o objeto de servi√ßo
   - Trate apenas convers√£o de interface/dados

6. **Clientes usam adapter** via interface do cliente

## ‚öñÔ∏è Pr√≥s e Contras

### ‚úÖ Vantagens:
- **Princ√≠pio da Responsabilidade √önica**: Separa convers√£o de interface da l√≥gica
- **Princ√≠pio Aberto/Fechado**: Novos adapters sem quebrar c√≥digo existente
- **Reutiliza√ß√£o**: Aproveita c√≥digo existente incompat√≠vel
- **Flexibilidade**: M√∫ltiplos adapters para diferentes servi√ßos

### ‚ùå Desvantagens:
- **Complexidade aumenta**: Introduz novas interfaces e classes
- **Camada extra**: Pode impactar performance
- **Alternativa simples**: √Äs vezes √© mais f√°cil alterar a classe de servi√ßo

## üîó Diferen√ßas de Outros Padr√µes

| Padr√£o | Prop√≥sito | Interface | Estrutura |
|--------|-----------|-----------|-----------|
| **Adapter** | Compatibilizar interfaces | Muda completamente | Wrapper de objeto |
| **Decorator** | Adicionar comportamento | Mesma ou estendida | Composi√ß√£o recursiva |
| **Facade** | Simplificar subsistema | Nova interface | M√∫ltiplos objetos |
| **Proxy** | Controlar acesso | Mesma interface | Mesmo objeto |

## üîó Rela√ß√µes com Outros Padr√µes

- **Bridge**: Projetado antecipadamente vs Adapter usado com c√≥digo existente
- **Decorator**: Interface similar/estendida vs Adapter interface diferente
- **Facade**: Interface para subsistema vs Adapter para objeto √∫nico
- **Proxy**: Mesma interface vs Adapter interface diferente

## üìö Conceitos-Chave para Lembrar

1. **Tradu√ß√£o de interfaces**: Ess√™ncia do padr√£o
2. **Object vs Class Adapter**: Composi√ß√£o vs heran√ßa
3. **Transpar√™ncia**: Cliente n√£o sabe sobre o adapter
4. **Bidirecionais**: Adapters podem converter nos dois sentidos
5. **Legacy integration**: Casos de uso mais comuns

## üîç Analogia do Mundo Real

**Adaptador de tomada de viagem**: Quando voc√™ viaja dos EUA para a Europa, precisa de um adaptador para conectar seu laptop. O adaptador tem soquete americano de um lado e plugue europeu do outro, permitindo que dispositivos incompat√≠veis funcionem juntos.

## ‚ö†Ô∏è Considera√ß√µes Importantes

### Tipos de Adapter:
- **Object Adapter**: Usa composi√ß√£o (mais flex√≠vel)
- **Class Adapter**: Usa heran√ßa m√∫ltipla (limitado a linguagens que suportam)

### Padr√µes relacionados:
- **Two-way Adapter**: Convers√£o bidirecional
- **Pluggable Adapter**: Interface parametriz√°vel
- **Default Adapter**: Implementa√ß√£o padr√£o vazia

---

> **üí° Dica de Estudo:** Adapter √© como um "tradutor" entre dois objetos que falam "idiomas" diferentes. Use quando precisar integrar c√≥digo existente que n√£o pode ser modificado.

> **üìñ Refer√™ncia:** [Refactoring Guru - Adapter](https://refactoring.guru/design-patterns/adapter)
