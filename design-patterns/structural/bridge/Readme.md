# Bridge

## üéØ Inten√ß√£o

O Bridge √© um padr√£o de projeto estrutural que permite dividir uma classe grande ou um conjunto de classes intimamente relacionadas em duas hierarquias separadas‚Äî**abstra√ß√£o** e **implementa√ß√£o**‚Äîque podem ser desenvolvidas independentemente uma da outra.

## üö© Problema

Imagine que voc√™ tem uma classe geom√©trica `Shape` com subclasses `Circle` e `Square`. Voc√™ quer estender essa hierarquia para incorporar cores, criando subclasses `Red` e `Blue`. Como j√° tem duas subclasses, precisar√° criar quatro combina√ß√µes: `BlueCircle`, `RedSquare`, etc.

### Explos√£o Combinat√≥ria:
```
Shape
‚îú‚îÄ‚îÄ Circle
‚îÇ   ‚îú‚îÄ‚îÄ RedCircle
‚îÇ   ‚îî‚îÄ‚îÄ BlueCircle
‚îî‚îÄ‚îÄ Square
    ‚îú‚îÄ‚îÄ RedSquare
    ‚îî‚îÄ‚îÄ BlueSquare
```

**Problema**: Adicionar novas formas e cores faz a hierarquia crescer exponencialmente. Para adicionar um tri√¢ngulo, voc√™ precisaria de duas subclasses (uma para cada cor). Depois, adicionar uma nova cor exigiria tr√™s subclasses (uma para cada forma).

**Exemplo problem√°tico:**
```java
// Explos√£o de classes
class RedCircle extends Circle { ... }
class BlueCircle extends Circle { ... }
class RedSquare extends Square { ... }
class BlueSquare extends Square { ... }
// Para N formas e M cores = N√óM classes!
```

## ‚úÖ Solu√ß√£o

O Bridge resolve esse problema **trocando heran√ßa por composi√ß√£o**. Voc√™ extrai uma das dimens√µes em uma hierarquia de classes separada, fazendo a classe original referenciar um objeto da nova hierarquia.

### Separa√ß√£o de Responsabilidades:
- **Abstra√ß√£o**: Camada de controle de alto n√≠vel (ex: GUI)
- **Implementa√ß√£o**: Trabalho real de baixo n√≠vel (ex: API do SO)

```java
// Antes: Heran√ßa m√∫ltipla
class RedCircle extends Circle { ... }

// Depois: Composi√ß√£o
class Circle {
    private Color color; // Bridge para implementa√ß√£o
    
    public void draw() {
        color.applyColor(); // Delega para implementa√ß√£o
        // ... desenhar c√≠rculo
    }
}
```

## üèóÔ∏è Estrutura

```
Client ‚Üí Abstraction ‚Üê--bridge--‚Üí Implementation
           ‚Üë                           ‚Üë
    RefinedAbstraction          ConcreteImplementation
```

### Componentes:
- **Abstraction**: L√≥gica de controle de alto n√≠vel, referencia Implementation
- **RefinedAbstraction**: Variantes da l√≥gica de controle
- **Implementation**: Interface comum para todas as implementa√ß√µes concretas
- **ConcreteImplementation**: C√≥digo espec√≠fico da plataforma
- **Client**: Trabalha com Abstraction, mas vincula com Implementation

## üíª Exemplos Pr√°ticos

### Exemplo 1: Sistema de Notifica√ß√µes

```java
// Implementation - diferentes canais de envio
interface NotificationSender {
    void sendNotification(String title, String message);
}

class EmailSender implements NotificationSender {
    private String emailAddress;
    
    public EmailSender(String email) {
        this.emailAddress = email;
    }
    
    @Override
    public void sendNotification(String title, String message) {
        System.out.println("Email para " + emailAddress);
        System.out.println("Assunto: " + title);
        System.out.println("Mensagem: " + message);
    }
}

class SMSSender implements NotificationSender {
    private String phoneNumber;
    
    public SMSSender(String phone) {
        this.phoneNumber = phone;
    }
    
    @Override
    public void sendNotification(String title, String message) {
        System.out.println("SMS para " + phoneNumber);
        System.out.println(title + ": " + message);
    }
}

class SlackSender implements NotificationSender {
    private String channelId;
    
    public SlackSender(String channel) {
        this.channelId = channel;
    }
    
    @Override
    public void sendNotification(String title, String message) {
        System.out.println("Slack para canal " + channelId);
        System.out.println("**" + title + "**\n" + message);
    }
}

// Abstraction - diferentes tipos de notifica√ß√£o
abstract class Notification {
    protected NotificationSender sender;
    
    public Notification(NotificationSender sender) {
        this.sender = sender;
    }
    
    public abstract void send(String title, String message);
}

// Refined Abstractions
class SimpleNotification extends Notification {
    public SimpleNotification(NotificationSender sender) {
        super(sender);
    }
    
    @Override
    public void send(String title, String message) {
        sender.sendNotification(title, message);
    }
}

class UrgentNotification extends Notification {
    public UrgentNotification(NotificationSender sender) {
        super(sender);
    }
    
    @Override
    public void send(String title, String message) {
        sender.sendNotification("üö® URGENTE: " + title, message.toUpperCase());
    }
}

class ReminderNotification extends Notification {
    public ReminderNotification(NotificationSender sender) {
        super(sender);
    }
    
    @Override
    public void send(String title, String message) {
        String reminderMessage = "üìÖ Lembrete: " + message;
        sender.sendNotification(title, reminderMessage);
    }
}

// Uso
public class NotificationExample {
    public static void main(String[] args) {
        // Diferentes combina√ß√µes: tipo de notifica√ß√£o √ó canal de envio
        
        // Notifica√ß√£o simples por email
        Notification emailNotification = new SimpleNotification(
            new EmailSender("user@example.com")
        );
        emailNotification.send("Bem-vindo", "Conta criada com sucesso!");
        
        System.out.println();
        
        // Notifica√ß√£o urgente por SMS
        Notification urgentSMS = new UrgentNotification(
            new SMSSender("+5511999999999")
        );
        urgentSMS.send("Sistema", "Servidor fora do ar");
        
        System.out.println();
        
        // Lembrete por Slack
        Notification slackReminder = new ReminderNotification(
            new SlackSender("#dev-team")
        );
        slackReminder.send("Reuni√£o", "Daily meeting em 15 minutos");
    }
}
```

### Exemplo 2: Sistema de Desenho Multiplataforma

```java
// Implementation - diferentes APIs gr√°ficas
interface DrawingAPI {
    void drawCircle(int x, int y, int radius);
    void drawRectangle(int x, int y, int width, int height);
}

class WindowsAPI implements DrawingAPI {
    @Override
    public void drawCircle(int x, int y, int radius) {
        System.out.printf("Windows API: C√≠rculo em (%d,%d) raio %d%n", x, y, radius);
    }
    
    @Override
    public void drawRectangle(int x, int y, int width, int height) {
        System.out.printf("Windows API: Ret√¢ngulo em (%d,%d) %dx%d%n", x, y, width, height);
    }
}

class LinuxAPI implements DrawingAPI {
    @Override
    public void drawCircle(int x, int y, int radius) {
        System.out.printf("Linux API: C√≠rculo em (%d,%d) raio %d%n", x, y, radius);
    }
    
    @Override
    public void drawRectangle(int x, int y, int width, int height) {
        System.out.printf("Linux API: Ret√¢ngulo em (%d,%d) %dx%d%n", x, y, width, height);
    }
}

// Abstraction - formas geom√©tricas
abstract class Shape {
    protected DrawingAPI drawingAPI;
    
    protected Shape(DrawingAPI drawingAPI) {
        this.drawingAPI = drawingAPI;
    }
    
    public abstract void draw();
    public abstract void resize(double factor);
}

// Refined Abstractions
class Circle extends Shape {
    private int x, y, radius;
    
    public Circle(int x, int y, int radius, DrawingAPI drawingAPI) {
        super(drawingAPI);
        this.x = x;
        this.y = y;
        this.radius = radius;
    }
    
    @Override
    public void draw() {
        drawingAPI.drawCircle(x, y, radius);
    }
    
    @Override
    public void resize(double factor) {
        radius = (int) (radius * factor);
    }
}

class Rectangle extends Shape {
    private int x, y, width, height;
    
    public Rectangle(int x, int y, int width, int height, DrawingAPI drawingAPI) {
        super(drawingAPI);
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    
    @Override
    public void draw() {
        drawingAPI.drawRectangle(x, y, width, height);
    }
    
    @Override
    public void resize(double factor) {
        width = (int) (width * factor);
        height = (int) (height * factor);
    }
}

// Uso
public class DrawingExample {
    public static void main(String[] args) {
        // Formas podem usar qualquer API
        Shape[] shapes = {
            new Circle(10, 10, 5, new WindowsAPI()),
            new Rectangle(20, 20, 30, 15, new WindowsAPI()),
            new Circle(50, 50, 8, new LinuxAPI()),
            new Rectangle(60, 60, 25, 20, new LinuxAPI())
        };
        
        for (Shape shape : shapes) {
            shape.draw();
            shape.resize(1.5);
            shape.draw();
            System.out.println();
        }
    }
}
```

## üéØ Quando Usar?

### ‚úÖ Use quando:
- **Dividir classe monol√≠tica** com v√°rias variantes de funcionalidade
- **Estender classe em dimens√µes ortogonais** (independentes)
- **Trocar implementa√ß√µes em runtime**
- **Desenvolver partes independentemente** (equipes diferentes)

### üìù Exemplos de uso:
- **Aplica√ß√µes multiplataforma**: GUI + API do SO
- **Drivers de dispositivos**: Interface comum + implementa√ß√µes espec√≠ficas
- **Sistemas de persist√™ncia**: DAO + diferentes bancos de dados
- **Protocolos de comunica√ß√£o**: Interface + TCP/UDP/HTTP

### ‚ùå Evite quando:
- **Classe √© altamente coesa**: Pode aumentar complexidade desnecessariamente
- **Apenas uma dimens√£o de varia√ß√£o**: Use Strategy ou State
- **Hierarquia simples**: Pode ser over-engineering

## üöÄ Como Implementar

1. **Identifique dimens√µes ortogonais**: abstra√ß√£o/plataforma, dom√≠nio/infraestrutura, front-end/back-end

2. **Defina opera√ß√µes do cliente** na classe abstra√ß√£o base

3. **Determine opera√ß√µes da plataforma** e declare na interface de implementa√ß√£o

4. **Crie implementa√ß√µes concretas** para todas as plataformas

5. **Adicione campo de refer√™ncia** na abstra√ß√£o para o tipo de implementa√ß√£o

6. **Crie abstra√ß√µes refinadas** estendendo a abstra√ß√£o base

7. **Cliente associa implementa√ß√£o** √† abstra√ß√£o via construtor

## ‚öñÔ∏è Pr√≥s e Contras

### ‚úÖ Vantagens:
- **Classes/apps independentes de plataforma**
- **Cliente trabalha com abstra√ß√µes** de alto n√≠vel
- **Princ√≠pio Aberto/Fechado**: Novas abstra√ß√µes e implementa√ß√µes independentes
- **Princ√≠pio da Responsabilidade √önica**: L√≥gica vs detalhes de plataforma
- **Desenvolvimento paralelo**: Equipes independentes

### ‚ùå Desvantagens:
- **Complexidade aumenta** em classes altamente coesas
- **Overhead de indire√ß√£o**: Camada extra de abstra√ß√£o
- **Pode ser over-engineering** para casos simples

## üîó Diferen√ßas de Outros Padr√µes

| Padr√£o | Quando usar | Estrutura | Foco |
|--------|-------------|-----------|------|
| **Bridge** | Design antecipado | Duas hierarquias | Separar abstra√ß√£o/implementa√ß√£o |
| **Adapter** | C√≥digo existente | Wrapper | Compatibilizar interfaces |
| **Strategy** | Runtime behavior | Algoritmos intercambi√°veis | Trocar comportamento |
| **State** | Estado do objeto | Estados como classes | Mudar comportamento por estado |

## üîó Rela√ß√µes com Outros Padr√µes

- **Abstract Factory + Bridge**: Encapsular rela√ß√µes entre abstra√ß√µes e implementa√ß√µes
- **Builder + Bridge**: Director como abstra√ß√£o, builders como implementa√ß√µes
- **Strategy**: Estrutura similar, mas Strategy foca em algoritmos intercambi√°veis
- **State**: Estrutura similar, mas State foca em mudan√ßas de comportamento

## üìö Conceitos-Chave para Lembrar

1. **Composi√ß√£o > Heran√ßa**: Evita explos√£o combinat√≥ria
2. **Duas hierarquias**: Abstra√ß√£o (controle) + Implementa√ß√£o (trabalho)
3. **Design antecipado**: Planejado desde o in√≠cio vs Adapter (adapta√ß√£o)
4. **Independ√™ncia**: Desenvolver abstra√ß√µes e implementa√ß√µes separadamente
5. **Runtime switching**: Trocar implementa√ß√µes dinamicamente
6. **Dimens√µes ortogonais**: Varia√ß√µes independentes

## üîç Analogia do Mundo Real

**Controle remoto e dispositivos**: Um controle remoto (abstra√ß√£o) pode operar diferentes dispositivos como TV, r√°dio, ar-condicionado (implementa√ß√µes). O controle define opera√ß√µes de alto n√≠vel (ligar, volume, canal), enquanto cada dispositivo implementa essas opera√ß√µes de forma espec√≠fica. Voc√™ pode ter controles b√°sicos ou avan√ßados funcionando com qualquer dispositivo.

## ‚ö†Ô∏è Considera√ß√µes Importantes

### Design antecipado:
- Bridge √© projetado desde o in√≠cio
- Permite desenvolvimento independente de equipes
- Facilita adi√ß√£o de novas plataformas/abstra√ß√µes

### Vs Strategy Pattern:
- **Bridge**: Separa√ß√£o estrutural permanente
- **Strategy**: Intercambio comportamental tempor√°rio

### Performance:
- Indire√ß√£o adicional pode impactar performance
- Benef√≠cio de flexibilidade geralmente compensa

---

> **üí° Dica de Estudo:** Bridge separa "o que faz" (abstra√ß√£o) de "como faz" (implementa√ß√£o). √â como ter um controle remoto universal que funciona com qualquer aparelho - cada bot√£o tem a mesma fun√ß√£o, mas cada aparelho responde diferente.

> **üìñ Refer√™ncia:** [Refactoring Guru - Bridge](https://refactoring.guru/design-patterns/bridge)
